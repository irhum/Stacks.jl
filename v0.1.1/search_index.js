var documenterSearchIndex = {"docs":
[{"location":"advanced/#Advanced-Uses","page":"Advanced Uses","title":"Advanced Uses","text":"","category":"section"},{"location":"advanced/#Collect-Variables","page":"Advanced Uses","title":"Collect Variables","text":"","category":"section"},{"location":"advanced/","page":"Advanced Uses","title":"Advanced Uses","text":"You can collect intermediate variables you are interested in with ' on that variable. This allows you to define and train a model, and only make changes to its structure (and not the layers of the model itself) if you need access to intermediate outputs for downstream tasks (e.g. style transfer using a pretrained CNN). For example:","category":"page"},{"location":"advanced/","page":"Advanced Uses","title":"Advanced Uses","text":"julia> @functopo (x,y) => (a,b,c,d') => (w',r',y) => (m,n)' => z\n# FuncTopo{\"(x, y) => ((a, b, c, d') => ((w', r', y) => (((m, n))' => z)))\"}\n# function(model, x, y)\n#     (a, b, c, d) = model[1](x, y)\n#     %1 = d\n#     (w, r, y) = model[2](a, b, c, d)\n#     %2 = (w, r)\n#     (m, n) = model[3](w, r, y)\n#     %3 = (m, n)\n#     z = model[4](m, n)\n#     (z, (var\"%1\", var\"%2\", var\"%3\"))\n# end","category":"page"},{"location":"advanced/#Interpolation","page":"Advanced Uses","title":"Interpolation","text":"","category":"section"},{"location":"advanced/","page":"Advanced Uses","title":"Advanced Uses","text":"TopoChains.jl supports interpolation, so you can use a variable to hold a substructure or the unroll number. ","category":"page"},{"location":"advanced/","page":"Advanced Uses","title":"Advanced Uses","text":"note: Note\nThe interpolation variable should always be at the top level of the module since we can only get that value with eval. (To interpolate local variables, use @functopo_str \"topo_pattern\" instead)","category":"page"},{"location":"advanced/","page":"Advanced Uses","title":"Advanced Uses","text":"@functopo_str","category":"page"},{"location":"advanced/#TopoChains.@functopo_str","page":"Advanced Uses","title":"TopoChains.@functopo_str","text":"@functopo_str \"structure\"\n\nSimilar to @functopo, except that structure is a String. Useful when performing local interpolation of values into structure.\n\n\n\n\n\n","category":"macro"},{"location":"advanced/","page":"Advanced Uses","title":"Advanced Uses","text":"N = 3\n\ntopo = @functopo (y => (z1, z2) => t) => $N\n\n# alternatively\n# topo = @functopo_str \"(y => (z1, z2) => t) => $N\"\n\ntopo\n# FuncTopo{\"(y => ((z1, z2) => t)) => 3\"}\n# function(model, y)\n#     (z1, z2) = model[1](y)\n#     t = model[2](z1, z2)\n#     (z1, z2) = model[3](t)\n#     t = model[4](z1, z2)\n#     (z1, z2) = model[5](t)\n#     t = model[6](z1, z2)\n#     t\n# end","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n  using TopoChains\n  using Flux\nend","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Adapted from Transformers.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"TopoChains.jl allows you to cleanly build flexible neural networks whose layers can take any number of inputs, and produce any number of outputs. It achieves this by seperating the layers from the overall topology (that is, the structure) of the model. This is done through an instance of the FuncTopo type, which specifies the inputs/outputs the layers take in/produce. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides two core features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@functopo: A macro that uses a compact DSL (Domain Specific Language) to store the structure of the model in a FuncTopo.\nTopoChain: Similar to a Flux.Chain, except it takes in an FuncTopo as its first argument to determine how to handle the multiple inputs/outputs across layers.","category":"page"},{"location":"#TopoChain","page":"Introduction","title":"TopoChain","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A TopoChain is similar to a Flux.Chain and comes with many of the same features, such as parameter collection, indexing, slicing, etc. The big change is that the first input to a TopoChain is a FuncTopo, which specifies how the layers should be called. This allows us to flexibly build complex architectures.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"TopoChain","category":"page"},{"location":"#TopoChains.TopoChain","page":"Introduction","title":"TopoChains.TopoChain","text":"TopoChain(topo::FuncTopo, layers...)\n\nSimilar to a Flux.Chain, with the addition of the use of an FuncTopo to define the order/structure of the functions called.\n\nExample\n\njulia> topo = @functopo x:x => a:x => b:(a, b) => c => o\n\njulia> model = TopoChain(topo,\n                Dense(32, 64),\n                Dense(32, 64),\n                (x, y) -> x .* y, \n                Dropout(0.1))\n\nTopoChain(Dense(32, 64), Dense(32, 64), #5, Dropout(0.1)) representing the following function composition: \nfunction(x)\n    a = Dense(32, 64)(x)\n    b = Dense(32, 64)(x)\n    c = #5(a, b)\n    o = Dropout(0.1)(c)\n    o\nend\n\n\n\n\n\n","category":"type"},{"location":"","page":"Introduction","title":"Introduction","text":"As we can see, with the help of the FuncTopo, the TopoChain not only holds the layers in a model, but also information on how to call the layers in a model as well.","category":"page"},{"location":"#FuncTopo","page":"Introduction","title":"FuncTopo","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We store the structure of the model in a FuncTopo, short for \"Function Topology\", by noting that a model is essentially a large function composed of many smaller functions. At its core, it is simply used to define inputs and outputs for each function in a sequence of function calls. Consider it a supercharged version of Julia's piping operator (|>). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FuncTopos are usually created by using the @functopo macro as shown:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@functopo","category":"page"},{"location":"#TopoChains.@functopo","page":"Introduction","title":"TopoChains.@functopo","text":"@functopo structure\n\nCreate a FuncTopo to apply functions according to the given structure.\n\nExample\n\njulia> @functopo (x1, x2):(x1, x2) => a:x1 => b:(a, b) => c => o\nFuncTopo{\"(x1, x2):(x1, x2) => (a:x1 => (b:(a, b) => (c => o)))\"}\nfunction(model, x1, x2)\n    a = model[1](x1, x2)\n    b = model[2](x1)\n    c = model[3](a, b)\n    o = model[4](c)\n    o\nend\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Introduction","title":"Introduction","text":"We now take a look at how @functopo is used, as well a deep dive into the syntax used in structure in the following sections, so you can write your own ones for use in your own models!","category":"page"},{"location":"#A-first-example","page":"Introduction","title":"A first example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Suppose you have inputs x1 and x2 you want to pass through the functions f, g and h as follows to get the output o: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<p align=\"center\">\n<img src=\"./assets/example1.png\" width=\"200\"/>\n</p>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You could do the following in regular Julia:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"a = f(x1, x2)\nb = g(x1)\nc = h(a, b)\no = m(c)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is functional, but gets increasingly unwieldy as the number of functions/layers in your models grow. With the TopoChains.jl approach, we seperate the structure from the actual function calls. In this case, we first define the structure as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"topo = @functopo (x1, x2):(x1, x2) => a:x1 => b:(a, b) => c => o","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The @functopo macro then takes the information given, and produces the FuncTopo instance topo that keeps track of how to call the functions, once given the functions: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"topo\n# FuncTopo{\"(x1, x2):(x1, x2) => (a:x1 => (b:(a, b) => (c => o)))\"}\n# function(model, x1, x2)\n#     a = model[1](x1, x2)\n#     b = model[2](x1)\n#     c = model[3](a, b)\n#     o = model[4](c)\n#     o\n# end","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here, model stands in for an iterable (e.g. a Tuple or Vector) of functions and layers. While the most typical use of an FuncTopo will be passing it as input to a TopoChain, we can indeed use topo directly by passing in the functions and inputs:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"x1 = 3\nx2 = 2\n\nf(x, y) = x^2 - y\ng(x) = x^3\nh(x, y) = x + y\nm(x) = mod(x, 4)\n\ntopo((f, g, h, m), x1, x2) # 2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Let's take a deep dive into the syntax used in defining the structure here.","category":"page"},{"location":"#The-syntax-of-FuncTopo","page":"Introduction","title":"The syntax of FuncTopo","text":"","category":"section"},{"location":"#.-Variable-names","page":"Introduction","title":"1. Variable names","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We use multiple variable names when defining the structure (e.g. x, c, etc.). These are the names of the intermediate outputs in the function generated by FuncTopo. Similar to how x in g(x) = x^3 has no relation with a previously defined x in the Julia session, the variables used to specify the structure have no relation with previously defined variables.","category":"page"},{"location":"#.-Applying-functions","page":"Introduction","title":"2. Applying functions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Each application of a function is represented with a =>, with the input variables on the left and output variables on the right. For instance, a => b means \"take the variable a and pass it to the function to produce the output b. This also allows us to chain functions together. Suppose you want to chain the functions p, q and r as follows: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"y = r(q(p(x))) ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You could equivalently write the following with the TopoChains.jl approach, seperating the structure from the functions:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia\ntopo = @functopo x:x => a:a => b:b => y \ny = topo((p, q, r), x) ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"When the actual function calls are made, the functions are used in the order they were passed in. Here the tuple of functions is (p, q, r) and so the first arrow in structure corresponds to applying the first function p, the second arrow applies q, and so forth.","category":"page"},{"location":"#.-Seperating-inputs-and-outputs","page":"Introduction","title":"3. Seperating inputs and outputs","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Notice that we use a : to seperate the input/output variable names for each function call. If the : is not present, we will by default assume that all output variables are the inputs of the next function call. This can be used to simplify structures. Above, we wrote","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@functopo x:x => a:a => b:b => y ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"when we could just as well have written","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@functopo x => a => b => y ","category":"page"},{"location":"#.-Multiple-inputs-and-outputs","page":"Introduction","title":"4. Multiple inputs and outputs","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"When a function has multiple inputs/outputs, we use a tuple of variables instead of variables. For instance, a function that takes two inputs and produces three outputs would be specified as (a, b) => (x, y, z)","category":"page"},{"location":"#Summary","page":"Introduction","title":"Summary","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The complete syntax for a structure can then be viewed as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(input arguments):(function1 inputs) => (function1 outputs):(function2 inputs):(function2 outputs) => .... => (function_n outputs):(return variables)","category":"page"},{"location":"#Repeated-Substructures","page":"Introduction","title":"Repeated Substructures","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Suppose in the structure of your model, there are repeated substructures. For instance, suppose you have a pair of layers: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The first of which takes an output and produces two outputs\nThe second takes two outputs and produces one output","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"And say that this pair structure is repeated 3x in your model. Instead of writing it out in full, you can do so more concisely with the following syntax:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"topo = @functopo (y => (z1, z2) => t) => 3","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"When the output of a => is an integer N instead of a variable, instead of applying a function we repeat the sub-structure (specified in between the brackets ( and )) N times. Indeed, we can see this produces the expected behavior:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"topo \n# FuncTopo{\"(y => ((z1, z2) => t)) => 3\"}\n# function(model, y)\n#     (z1, z2) = model[1](y)\n#     t = model[2](z1, z2)\n#     (z1, z2) = model[3](t)\n#     t = model[4](z1, z2)\n#     (z1, z2) = model[5](t)\n#     t = model[6](z1, z2)\n#     t\n# end","category":"page"},{"location":"#Nested-repeated-substructures","page":"Introduction","title":"Nested repeated substructures","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We can also nest our substructure repeats. This allows us to quickly specify complex models rather concisely. For instance:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"topo = @functopo x => ((y => z => t) => 3 => w) => 2\n\ntopo\n# FuncTopo{\"x => (((y => (z => t)) => (3 => w)) => 2)\"}\n# function(model, x)\n#     y = model[1](x)\n#     z = model[2](y)\n#     t = model[3](z)\n#     z = model[4](t)\n#     t = model[5](z)\n#     z = model[6](t)\n#     t = model[7](z)\n#     w = model[8](t)\n#     z = model[9](w)\n#     t = model[10](z)\n#     z = model[11](t)\n#     t = model[12](z)\n#     z = model[13](t)\n#     t = model[14](z)\n#     w = model[15](t)\n#     w\n# end","category":"page"}]
}
